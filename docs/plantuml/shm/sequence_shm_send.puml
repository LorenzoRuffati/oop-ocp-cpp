'https://www.planttext.com/?text=ZLN1Rjim3BthAvWSTaXGO6S3xHeawCaTXhf33qKHg3QT29KjGvBJfkZ7Zv8LsMg3OXSZ91_9nqVQkJQMQzit4efzipNOLgZPhDDyrt2mgDx1wXuPOrPOYJ0lzbnZ1GqsIXzXmCCpxlb1g5xF6Uked2X5nrlx6Lruz1ouWQ9Ws5B98s6muTrUQOHIALqDuTlrXZshDvYldK-qt0hLWY4kfPt7r3lahdsfUcfsu4FfkyrT14XLlfWjBwque0_cgqynYSIytGt1_2ofxdZYz8VY5H2lY5jJ59xxklOGXs0xhVeEIetS8WFmpUcd6nde0HTNzCnWxG5G2uc9_rxtRUaYme9LmBjEgquBvp7YFSNU4ad2HH-DlbYGzIFO-IerSs-6V2AxM6GWMchqAkmUAZJ2RUl0PJ_syJ2oeYDVPP2JTiDa-FZpAU5KeAMXjB7-cBQrv3kdWhHqB2TDAuK6McK1tuHnz2UaDhuRfKwPRZBeb4a6NIupUEN4dNOl93MGeFqv6E1Q4p5NGAFjTKi_AaptyF7nuNR9JkjogKT6b13KWKxAJVAR28gcazZGjacNMkbmy2RaifZlJk2qdryNLqMnN2Qgx4WLXzaw3DHQDSErHuvZTAmzb3Q35g5g1WSihT91qqzAm-Kbt71fSA9fld9PxjeVHVNsv2DHbmZACtBIos3mSHPWqntG5NZ1jI258eDOPXpqmIFyb7IzViRmseu7b9y80NNwMiOTs8bBe9Aqk96Y2vcZyuiGKOTGVTpOH5iwUS_jEptlTP_A6Td1SFj8VVvh4Vaayvp8uQeVpb-rnDgUqPnUZjbiMi9RunSWDVF4TD-0IN9gELLBgSpmZJA9_syhHViI0cw4QthGdyW_
@startuml Shm_sender
!pragma teoz true


title "Shared memory sender behaviour"

participant "Shared memory Sender" as SS
entity "Semaphore coord" as SMCD
box "Coordination struct"
entity "Reader count var" as RDR
entity "locks_active" as LA
entity "locks_leaving" as LL
entity "Semaphore copy" as SMCP
end box
entity "Copy buff" as MCP

group create
  activate SS
  SS -> SS: Create file
  SS -> SS: Truncate it to appropriate size
  SS -> SS: Mmap it
  SS -> RDR**
  & SS -> LA**
  & SS -> LL**
  SS -> SMCP**: init with desired value
  SS -> MCP**
  
  SS -> LA: Lock active[0]
  SS -> SS: Set first_send_flag
  alt semaphore does not exist
    SS -> SMCD**
  end
  SS -> SMCD: post
  SS -> RDR++: wait until all readers arrived
  return
  deactivate SS
  |||
end


group ready
note over SS: Not implemented for senders
end






group buff size
  ?->SS++
  SS -> SS: get buff_size from coord
  return buff_size
end





group send
  ?->SS++: vector
  alt first_send_flag == False
    SS -> LA++: lock[idx]
    return
    SS -> LL: release[!idx]
  end
  SS -> MCP++: write vector
  return
  SS -> SS: Write size to coord struct
  SS -> LL++: lock idx
  return
  SS -> LA: release[idx]
  
  SS -> SS: Flip idx
  SS -> SS: first_send_flag = False
  return
end











group destructor
  alt first_send_flag == True
    SS -> LA: release [0]
  else first_send_flag == False
    SS -> LL: release [!idx]
  end
  SS -> RDR++: Wait until all readers left
  return
  SS -> SMCD!!
  SS -> RDR!!
  & SS -> LA!!
  & SS -> LL!!
  & SS -> SMCP!!
  SS -> MCP!!
  SS -> SS: close files
  SS -> SS: Unlink files
end
@enduml